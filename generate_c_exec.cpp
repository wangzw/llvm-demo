#include "llvm-c/Core.h"
#include "llvm-c/ExecutionEngine.h"
#include "llvm-c/Target.h"

#include "clang/Tooling/Tooling.h"
#include "clang/AST/ASTConsumer.h"
#include "clang/Driver/Compilation.h"
#include "clang/Driver/Driver.h"
#include "clang/Driver/Tool.h"
#include "clang/Frontend/ASTUnit.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Frontend/FrontendDiagnostic.h"
#include "clang/Frontend/TextDiagnosticPrinter.h"
#include "clang/Tooling/ArgumentsAdjusters.h"
#include "clang/Tooling/CompilationDatabase.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/Option/Option.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/Host.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/Module.h"
#include "clang/Driver/Driver.h"
#include "clang/CodeGen/CodeGenAction.h"

#include <iostream>

using namespace clang;
using namespace clang::tooling;

class ToolActionWrapper : public tooling::ToolAction {
public:
    ToolActionWrapper(clang::CodeGenAction *act) : act(act) {
    }

    ~ToolActionWrapper() {
        delete act;
    }

    bool runInvocation(clang::CompilerInvocation *Invocation,
                       clang::FileManager *Files,
                       clang::DiagnosticConsumer *DiagConsumer) {

        // Create a compiler instance to handle the actual work.
        clang::CompilerInstance Compiler;
        Compiler.setInvocation(Invocation);
        Compiler.setFileManager(Files);

        // Create the compilers actual diagnostics engine.
        Compiler.createDiagnostics(DiagConsumer, /*ShouldOwnClient=*/false);
        if (!Compiler.hasDiagnostics()) return false;

        Compiler.createSourceManager(*Files);

        const bool Success = Compiler.ExecuteAction(*act);

        Files->clearStatCaches();
        return Success;
    }

    llvm::Module *takeModule() {
        return act->takeModule();
    }

private:
    clang::CodeGenAction *act;
};

LLVMModuleRef CompileCCode(const char *code) {
    const char *fileName = "input.c";
    std::vector<std::string> args;
    args.push_back("generate_c_exec");
    args.push_back("-fsyntax-only");
    args.push_back("-g");
    // args.push_back("-O3");
    args.push_back(fileName);

    ToolActionWrapper *act =
        new ToolActionWrapper(new clang::EmitLLVMOnlyAction());

    ToolInvocation Invocation(args, act, new FileManager(FileSystemOptions()));

    Invocation.mapVirtualFile(fileName, code);

    if (!Invocation.run()) {
        std::cerr << "cannot compile the c code" << std::endl;
        exit(1);
    }

    llvm::Module *module = act->takeModule();

    if (!module) {
        std::cerr << "cannot take module from act" << std::endl;
        exit(1);
    }

    return wrap(module);
}

int main() {

    const char *ccode =
        "void abort(void);"
        "extern int puts(const char *);\n"
        "const char * GetMsg(void) {\n"
        "	abort();\n"
        "	return \"This is dynamically generated bytecode from C\\n\";\n"
        "}\n"
        "void PrintMsg(void) {\n"
        "	puts(GetMsg());\n"
        "}\n";

    // std::cout << ccode << std::endl;

    LLVMContextRef cxt;
    LLVMModuleRef module;
    char *error = NULL;

    const char *funcname = "PrintMsg";
    const char *moduleFile = "dumped_generate_c_exec.ll";

    LLVMInitializeNativeTarget();
    LLVMLinkInJIT();

    module = CompileCCode(ccode);

    cxt = LLVMGetGlobalContext();

    /**
     * dump module to file
     */
    if (LLVMPrintModuleToFile(module, moduleFile, &error)) {
        std::cerr << "cannot dump module to file " << (error ? error : "")
                  << std::endl;
        return -1;
    }

    LLVMExecutionEngineRef engine;

    if (LLVMCreateJITCompilerForModule(&engine, module, 0, &error)) {
        std::cerr << "cannot create execution engine " << (error ? error : "")
                  << std::endl;
        return -1;
    }

    LLVMValueRef func;
    if (LLVMFindFunction(engine, funcname, &func)) {
        std::cerr << "cannot find function " << funcname << " "
                  << (error ? error : "") << std::endl;
        return -1;
    }

    if (NULL == LLVMRunFunction(engine, func, 0, NULL)) {
        std::cerr << "cannot execure function " << funcname << std::endl;
    }

    LLVMContextDispose(cxt);

    return 0;
}
